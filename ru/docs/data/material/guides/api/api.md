

# Подход к проектированию API <meta data-oversett="" data-original-text="API design approach">

<p class="description">Мы многое узнали о том, как используется MUI, и переработка версии 1 позволила нам полностью переосмыслить API компонента.</p>

:::info
Проектировать API сложно, потому что можно сделать его простым, но на самом деле обманчиво сложным, или сделать его простым, но кажущимся сложным.
:::

[@sebmarkbage](https://twitter.com/sebmarkbage/status/728433349337841665)

Как [отметил](https://2014.jsconf.eu/speakers/sebastian-markbage-minimal-api-surface-area-learning-patterns-instead-of-frameworks.html) Себастьян Маркбадж, никакая абстракция не превосходит неправильные абстракции. Мы предоставляем низкоуровневые компоненты, чтобы максимально расширить возможности композиции.

## Композиция <meta data-oversett="" data-original-text="Composition">

Возможно, вы заметили некоторую непоследовательность в API относительно композиции компонентов. Чтобы обеспечить некоторую прозрачность, мы использовали следующие правила при разработке API:

1.  Использование реквизита `children` - это идиоматический способ создания композиции в React.
2.  Иногда нам нужна только ограниченная композиция дочерних компонентов, например, когда нам не нужно разрешать перестановку порядков дочерних компонентов. В этом случае предоставление явных реквизитов упрощает реализацию и повышает производительность; например, `Tab` принимает реквизиты `icon` и `label`.
3.  Согласованность API имеет значение.

## Правила <meta data-oversett="" data-original-text="Rules">

Помимо вышеупомянутого компромисса между композицией и порядком, мы применяем следующие правила:

### Распространение <meta data-oversett="" data-original-text="Spread">

Реквизиты, передаваемые компоненту, которые явно не документированы, распространяются на корневой элемент; например, реквизит `className` применяется к корню.

Теперь, допустим, вы хотите отключить рябь на `MenuItem`. Вы можете воспользоваться поведением распространения:

```jsx
<MenuItem disableRipple />
```

Реквизит `disableRipple` будет выглядеть следующим образом: [`MenuItem`](/material-ui/api/menu-item/) > [`ListItem`](/material-ui/api/list-item/) > [`ButtonBase`](/material-ui/api/button-base/).

### Нативные свойства <meta data-oversett="" data-original-text="Native properties">

Мы избегаем документирования собственных свойств, поддерживаемых DOM, таких как [`className`](/material-ui/customization/how-to-customize/#overriding-styles-with-class-names).

### CSS-классы <meta data-oversett="" data-original-text="CSS Classes">

Все компоненты принимают [`classes`](/material-ui/customization/how-to-customize/#overriding-styles-with-class-names) Дизайн классов отвечает двум ограничениям: сделать структуру классов как можно более простой, но при этом достаточной для реализации рекомендаций Material Design.

-   Класс, применяемый к корневому элементу, всегда называется `root`.
-   Все стили по умолчанию сгруппированы в одном классе.
-   Классы, применяемые к некорневым элементам, имеют префикс с именем элемента, например, `paperWidthXs` в компоненте Dialog.
-   Варианты, применяемые булевым реквизитом, **не** имеют префикса, например, класс `rounded`, применяемый реквизитом `rounded`.
-   Варианты, применяемые реквизитом enum, **имеют** префикс, например, класс `colorPrimary`, применяемый реквизитом `color="primary"`.
-   Вариант имеет **один уровень специфичности**. Реквизиты `color` и `variant` считаются вариантом. Чем ниже специфичность стиля, тем проще его переопределить.
-   Мы увеличиваем специфичность для модификатора варианта. Мы уже **сделали это** для псевдоклассов (`:hover`, `:focus`, и т.д.). Это позволяет гораздо больше контроля ценой большего количества шаблонов. Надеюсь, это также более интуитивно понятно.

```js
const styles = {
  root: {
    color: green[600],
    '&$checked': {
      color: green[500],
    },
  },
  checked: {},
};
```

### Вложенные компоненты <meta data-oversett="" data-original-text="Nested components">

Вложенные компоненты внутри компонента имеют:

-   свои собственные уплощенные реквизиты, если они являются ключевыми для абстракции компонента верхнего уровня, например, реквизит `id` для компонента `Input`.
-   собственный реквизит `xxxProps`, когда пользователям может понадобиться настраивать подкомпоненты внутреннего метода рендеринга, например, раскрывать реквизиты `inputProps` и `InputProps` для компонентов, использующих `Input` внутри компонента.
-   собственный реквизит `xxxComponent` для выполнения инъекций компонентов.
-   собственный `xxxRef` prop, когда может потребоваться выполнить императивные действия, например, выставление `inputRef` prop для доступа к собственному `input` на компоненте `Input`. Это помогает ответить на вопрос ["Как я могу получить доступ к элементу DOM?"](/material-ui/getting-started/faq/#how-can-i-access-the-dom-element).

### Именование реквизита <meta data-oversett="" data-original-text="Prop naming">

-   **Булево**
    
    -   Значение по умолчанию для булевого реквизита должно быть `false`. Это позволяет лучше использовать сокращенное обозначение. Рассмотрим пример ввода, который включен по умолчанию. Как следует назвать реквизит, управляющий этим состоянием? Он должен называться `disabled`:
        
        ```jsx
        ❌ <Input enabled={false} />
        ✅ <Input disabled />
        ```
        
    -   Если имя реквизита состоит из одного слова, то это должно быть прилагательное или существительное, а не глагол. Это связано с тем, что реквизит описывает _состояния_, а не _действия_. Например, входной реквизит может управляться состоянием, которое не может быть описано глаголом:
        
        ```jsx
        const [disabled, setDisabled] = React.useState(false);
        
        ❌ <Input disable={disabled} />
        ✅ <Input disabled={disabled} />
        ```
        

### Управляемые компоненты <meta data-oversett="" data-original-text="Controlled components">

Большинство управляемых компонентов управляются через реквизиты `value` и `onChange`, однако для состояния, связанного с отображением, используется комбинация `open` / `onClose` / `onOpen`. В случаях, когда событий больше, мы сначала ставим существительное, а затем глагол, например: `onPageChange`, `onRowsChange`.

### boolean vs. enum <meta data-oversett="" data-original-text="boolean vs. enum">

Есть два варианта разработки API для вариаций компонента: с помощью _булевых значений_ или с помощью _перечисления_. Для примера возьмем кнопку, которая имеет различные типы. У каждого варианта есть свои плюсы и минусы:

-   Вариант 1 _boolean_:
    
    ```tsx
    type Props = {
      contained: boolean;
      fab: boolean;
    };
    ```
    
    Этот API позволяет использовать сокращенную нотацию:`<Button>`, `<Button contained />`, `<Button fab />`.
    
-   Вариант 2 _enum_:
    
    ```tsx
    type Props = {
      variant: 'text' | 'contained' | 'fab';
    };
    ```
    
    Этот API более многословен:`<Button>`, `<Button variant="contained">`, `<Button variant="fab">`.
    
    Однако он предотвращает использование недопустимой комбинации, ограничивает количество раскрываемых реквизитов и может легко поддерживать новые значения в будущем.
    

Компоненты MUI используют комбинацию этих двух подходов в соответствии со следующими правилами:

-   _Булево_ используется, когда требуется **2** возможных значения.
-   _Перечисление_ используется, когда требуется **более 2** возможных значений, или если есть вероятность, что в будущем потребуются дополнительные возможные значения.

Возвращаясь к предыдущему примеру с кнопкой; поскольку для нее требуется 3 возможных значения, мы используем _перечисление_.

### Ссылка <meta data-oversett="" data-original-text="Ref">

Ссылка `ref` направляется на корневой элемент. Это означает, что, не изменяя корневой элемент через реквизит `component`, он направляется на самый внешний элемент DOM, который компонент рендерит. Если вы передадите другой компонент через реквизит `component`, ссылка будет присоединена к этому компоненту.

## Глоссарий <meta data-oversett="" data-original-text="Glossary">

-   **host component**: тип узла DOM в контексте `react-dom`, например, `'div'`. См. также [React Implementation Notes](https://reactjs.org/docs/implementation-notes.html#mounting-host-elements).
-   **host element**: узел DOM в контексте `react-dom`, например, экземпляр `window.HTMLDivElement`.
-   **крайний** компонент: первый компонент при чтении дерева компонентов сверху вниз, т.е. при поиске по ширине.
-   **корневой компонент**: крайний компонент, который отображает основной компонент.
-   **корневой элемент**: крайний элемент, который отображает основной компонент.
